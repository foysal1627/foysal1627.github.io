#include <Wire.h>
#include <VL53L1X.h>
#include <SoftwareSerial.h>

SoftwareSerial bluetooth(10, 11); 
VL53L1X sensor;

const int motor = 3; 

// --- স্মার্ট ফিল্টারিং ভেরিয়েবল ---
const int numReadings = 15;      
int readings[numReadings];      
int readIndex = 0;              
long total = 0;   
int lastValidDistance = 1000;    

// --- স্পাইক ফিল্টার (অস্বাভাবিক পরিবর্তন শনাক্ত করা) ---
const int maxChange = 350;       

// --- টাইমিং ভেরিয়েবল ---
unsigned long lastAlertTime = 0; 
const unsigned long alertInterval = 3000; 

void setup() {
  Serial.begin(9600);
  bluetooth.begin(9600);
  Wire.begin();
  Wire.setClock(400000); 

  if (!sensor.init()) {
    Serial.println("Sensor Error!");
    while (1);
  }

  // আউটডোর বা সরাসরি সূর্যের আলোতে ভালো পারফরম্যান্সের জন্য
  sensor.setDistanceMode(VL53L1X::Short); 
  sensor.setMeasurementTimingBudget(140000); // ১৪০ms সময় দেওয়া হয়েছে নিখুঁত রিডিংয়ের জন্য
  sensor.startContinuous(200); 

  pinMode(motor, OUTPUT);
  for (int i = 0; i < numReadings; i++) readings[i] = 0;
}

void loop() {
  int currentRaw = sensor.read();

  // ১. ভ্যালিডেশন এবং স্পাইক ফিল্টার
  if (currentRaw <= 0 || sensor.timeoutOccurred()) {
    currentRaw = lastValidDistance;
  }

  // যদি দূরত্ব হঠাৎ করে অনেক বেশি লাফ দেয় (Spike), তবে সেটিকে নয়েজ হিসেবে ধরা হবে
  if (abs(currentRaw - lastValidDistance) > maxChange) {
    // হুট করে লাফ না দিয়ে ধীরে ধীরে নতুন রিডিংয়ের দিকে যাওয়া
    if (currentRaw > lastValidDistance) currentRaw = lastValidDistance + 50;
    else currentRaw = lastValidDistance - 50;
  }
  lastValidDistance = currentRaw;

  // ২. মুভিং এভারেজ ফিল্টার (ভাইব্রেশন স্মুথ করার জন্য)
  total = total - readings[readIndex];
  readings[readIndex] = currentRaw;
  total = total + readings[readIndex];
  readIndex = (readIndex + 1) % numReadings;
  
  float distanceM = (total / numReadings) / 1000.0; 

  // ৩. মোটরের অটোমেটিক কন্ট্রোল লজিক
  int motorSpeed = 0;
  if (distanceM <= 1.5 && distanceM > 1.0) {
    motorSpeed = 65; // ১.৫ মিটারে মৃদু ভাইব্রেশন
  } 
  else if (distanceM <= 1.0 && distanceM > 0.05) {
    motorSpeed = 110; // ১ মিটারের নিচে তীব্র ভাইব্রেশন
  }
  else {
    motorSpeed = 0; // কোনো বাধা না থাকলে বন্ধ
  }
  analogWrite(motor, motorSpeed);

  // ৪. সিরিয়াল ও ব্লুটুথ অ্যালার্ট (৩ সেকেন্ড পরপর)
  if (distanceM <= 1.0 && distanceM > 0.05) {
    unsigned long currentMillis = millis();
    if (currentMillis - lastAlertTime >= alertInterval) {
      String msg = "Alert: Obstacle at " + String(distanceM) + "m";
      Serial.println(msg);
      bluetooth.println(msg);
      lastAlertTime = currentMillis; 
    }
  }

  delay(50); 
}
